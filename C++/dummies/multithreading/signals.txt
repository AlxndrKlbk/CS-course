"Сигналы".

Хорошая статья про сигналы: https://www.opennet.ru/base/dev/unix_signals.txt.html

Полный список сигналов в системе можно посмотреть через команду:

kill -l

Список основных сигналов можно посмотреть тут: https://en.wikipedia.org/wiki/Unix_signal
ANSI.

#include <signal.h>

signal(int signum, void (*act)(int));

Второй параметр может быть как указателем на функцию, определенную нами, так и константой SIG_DFL (обработчик по-умолчанию), SIG_IGN (игнорирование).
POSIX.

#include <signal.h>

int sigaction(int signum, const struct sigaction *act, struct sigaction oact);


Что же такое sigaction? Это структура, в которой содержатся как минимум следующее:

struct sigaction {
    void *sa_handler(int); // Может быть в т.ч. SIG_IGN или SIG_DFL.
    void *sa_sigaction(int, siginfo_t*, void*);
    sigset_t sa_mask; // Список блокируемых сигналов.
    int sa_flags;
};

Какие могут быть флаги?

SA_NODEFER - не блокировать сам полученный сигнал на время исполнения хендлера (в дополнение к sa_mask).

SA_RESETHAND - однократное исполнение хендлера (неперманентный хендлер).

SA_RESTART - возобновлять системные вызовы после окончания обработки сигнала.
Сигналы реального времени.

﻿Указываем флаг SA_SIGINFO. Сигналы реального времени лежат в промежутке от SIGRTMIN до SIGRTMAX.

Используется хендлер sa_sigaction, в который передается структура siginfo_t. Эта структура содержит расширенную информацию о пришедшем сигнале ( https://www.mkssoftware.com/docs/man5/siginfo_t.5.asp ), а также содержит si_value (int или void*) - информацию, переданную с сигналом.
Отправка сигналов.

﻿Есть несколько способов отправки сигналов. Основной из них - kill.

﻿kill(pid_t pid, int signum);

Тут все просто - отправляет процессу с указанным PID указанный сигнал. Однако мы еще можем отправит сигнал текущей группе процессов (pid = 0), ﻿группе процессов (pid < -1, ﻿смотрим по abs(pid)), вообще всем (pid = -1).

Чтобы отправить сигнал самому себе, есть вызов raise.

﻿raise(int signum); // kill(getpid(), signum);

Вызывается он синхронно. Если нам нужен SIGABRT - есть вызов abort().

Сигналы реального времени отправляются с помощью sigqueue.

﻿sigqueue(pid_t pid, ﻿int signum, ﻿const union sigval value /* int или void* - данные, передаются с сигналом */);

Ожидание сигнала.

Чтобы ожидать ближайший сигнал - вызываем pause(). Это - вечная пауза, но, как и ﻿любой системный вызов, она прервется сигналом. Ждать конкретный сигнал можно с помощью sigwait(...) и sigwaitinfo(...).
Зомби.

﻿Статья из википедии: https://en.wikipedia.org/wiki/Zombie_process

Умирая, процесс посылает своему родителю сигнал SIGCHLD.

Мы обязаны ﻿считать exit-code умершего потомка. Пока мы это не сделаем, он будет находиться в состоянии зомби (т.е. занимать pid и пр.). Init-процесс всегда считывает exit-code.

Чтобы считать exit-code, мы должны вызвать waitpid или wait.

﻿waitpid(pid_t pid /* -1 если не важно */, int *statusp /* Вот и exit-code */, ﻿int options /* WNOHANG для неблокирующего режима */);


// ﻿wait(&st) = waitpid(-1, &st, ﻿0);
